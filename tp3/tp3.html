<!DOCTYPE HTML>
<HTML lang="fr">
    <head>
	<META http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Programmation fonctionnelle : TP 3</title>
    </head>

    <body>
	<name>Programmation fonctionnelle : TP 3</name>

	<h3>On commence doucement pour éviter un claquage</h3>
	<p>
	    Écrire une fonction récursive <code>nbbase: int -> int ->
	    int</code> telle que <code>nbbase b n</code> retourne le nombre de chiffres
	    nécessaires à l'écriture de <code>n</code> en base
	    <code>b</code>.
	</p>


	<h3>Manipulation de listes</h3>
	<p>
	    On utilise à présent des listes polymorphes.
	    <br>
	    Proposer une implantation recursive pour chacune des fonctions suivantes :  
	    <ul>
		<li>  <tt>recherche: 'a -> 'a list ->
		    bool</tt> telle que <tt>recherche n l</tt> retourne <tt>true</tt>
		    si un élément <tt>n</tt> appartient à la
		    liste <tt>l</tt>, et <tt>false</tt> sinon.</li>
		<li><code>nb_occurrences : 'a -> 'a list -> int</code> telle que <code>nb_occurrences e l</code> retourne le nombre d'occurrences de <code>e</code> présent dans <code>l</code></li>
		<li>  <tt>supprime_tout: 'a -> 'a list
		    -> 'a list</tt> telle que <tt>supprime_tout n l</tt> retourne une
		    liste correspondant à <tt>l</tt> sans occurrence <tt>n</tt>.
		</li>
			    <li>  <tt>inverse: 'a list -> 'a
				list</tt>, qui retourne une liste correspondant à son
				argument dans l'ordre inverse. Dans un premier temps, on pourra
				utiliser la fonction de concaténation vue en cours.
				<li>  <tt>existe: ('a -> bool) -> 'a
				    list -> bool</tt>, telle que <tt>existe p l</tt> retourne
				    <tt>true</tt> si un élément de <tt>l</tt>
				    vérifie le prédicat <tt>p</tt>, et <tt>false</tt>
				    sinon.</li>
				    <!-- <li>  <code>recherche_k: 'a -> ('a * 'b) list
				       -> 'b</code>, qui retourne le premier objet de type <code>'b</code>
					 associé à une clé <code>k</code> de type <code>'a</code>.</li> -->
				    <li>  <code>recherche_tous_k: 'a -> ('a * 'b)
		list -> 'b list</code>, qui retourne la liste de tous les objets de type
					<code>'b</code> associés à une clé <code>k</code> de
					type <code>'a</code>.</li>
	    </ul>

	    Recoder les fonctions précédentes à l'aide de <code>List.fold_left</code> ou <code>List.fold_right</code>.
	    
	</p>
	<h3>Itérateurs</h3>
	<p>Proposer une fonction <code>scanl : ('a -> 'b -> 'a) -> 'a -> 'b list ->  'a list</code> telle que <code>scanl f l v0</code> retourne la listes des résultats intermédaires de l'exécution de <code>List.fold_left f v0 l</code>.</p>
	<p>Par exemple, <code>scanl (fun x y -> x+y) 0 [1;2;3;4;5]</code>
	    doit retourner la liste <code>[0;1;3;6;10;15]</code>
	</p>
	<p>Remarque : si la liste <code>l</code> est de longueur <code>n</code>, la liste retournée est de longueur <code>n+1</code></p>
	<p>Remarque : vous aurez dans doute besoin de la fonction <code>List.rev</code></p>

	<h3>Zipper</h3>
	<p>
	    Implanter le type des zippers sur liste, ainsi que les principales fonctions vue en cours.
	</p>

    </body>
</html>

